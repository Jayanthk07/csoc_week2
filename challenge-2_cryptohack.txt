Introduction:

1)Finding flags:  we can see the flag right there, beginner intro->crypto{y0ur_f1rst_fl4g}

2)Great snakes:   As we can see in the source code , it checks for the version of it via sys module , so having a python3 installed is enough to run and get teh flag -->crypto{z3n_0f_pyth0n}
  
3)network attacks: 
from pwn import *
import json

HOST = "socket.cryptohack.org"
port = 11112

r = remote(HOST,port)

def json_recieve():
    line = r.readline()
    return json.loads(line.decode())


def json_send(hsh):
    k = json.dumps(hsh).encode()
    r.sendline(k)


print(r.readline())
print(r.readline())
print(r.readline())
print(r.readline())

request = {
    "buy":"flag"
}

json_send(request)
k = json_recieve()
print(k)


#this code gave me the flag , as instructed in the sample code , i use remote() to start the connection and as the data is transferred i raw bytes ,i had to take care of converting it into bytes before sending and converting back to normal
 after recieving and i had to skip the first 4 lines bcuz as teh port opens the default things like welcome are sent , so as i dont need them , i can skip em







General:
->Encoding:
1)ASCII: in this challenge i had to just convert that list into bytesand decode() it to get the flag , hence the code is

>>> ans = bytes(k).decode()
>>> print(ans)
crypto{ASCII_pr1nt4bl3}



2)Hex:to convert a hex into ascii , i need to convert it into bytes and the decode it ,for converting hex to bytes , we use many things ,one of them is "bytes.fromhex()" so the code is

>>> l = "63727970746f7b596f755f77696c6c5f62655f776f726b696e675f776974685f6865785f737472696e67735f615f6c6f747d"
>>> 
>>> print(bytes.fromhex(l).decode())
crypto{You_will_be_working_with_hex_strings_a_lot}



3)base64: as we know the base64.b64encrypt() takes bytes as input , we first need to convert the given hex into bytes and then use that function , the code is,,

import base64
k = "72bca9b68fc16ac7beeb8f849dca1d8a783e8acf9679bf9269f7bf"
kb = bytes.fromhex(k)

l = base64.b64encode(kb)
print(l.decode())

this give the flag as crypto/Base+64+Encoding+is+Web+Safe/



4)Bytes and Big Integers: as for long numbers we cant just use byte() , we need a better function which is available in Crypto.Util.number as long_bytes(), so we convert the given long to bytes using this and then decode() to get the flag, code is

from Crypto.Util.number import *

k = 11515195063862318899931685488813747395775516287289682636499965282714637259206269
kb = long_to_bytes(k)
print(kb.decode()) 

the flag is crypto{3nc0d1n6_4ll_7h3_w4y_d0wn}



->XOR:
1)XOR starter:  here we have to xor "label" with 13 , this is xoring each byte with 13 , so convert label to bytes and the xor it element wise and then convert to bytes and decode() to get teh flag , otherwise we can also use the library
so normal code,,

k = "label"
kb = k.encode()
ans = [b1^13 for b1 in kb]
print(bytes(ans).decode())

library code,,

from pwn import xor
k = "label"
h = 13
ans = xor(k,h)  # xor returns the bytes , so we decode() it again
print(ans.decode())

the flag is crypto{aloha}



2)XOR properties: As we know a xor b xor b will be me a , as b xor b = 0 and a ^0 is a, we used that logic here to get the answer

from pwn import xor
k1=bytes.fromhex('a6c8b6733c9b22de7bc0253266a3867df55acde8635e19c73313')
k2_3=bytes.fromhex('c1545756687e7573db23aa1c3452a098b71a7fbf0fddddde5fc1')
flag=bytes.fromhex('04ee9855208a2cd59091d04767ae47963170d1660df7f56f5faf')
print(xor(k1,k2_3,flag))  

gives the flag -> crypto{x0r_i5_ass0c1at1v3}


3)favourite byte: since we know the whole thing is xored with the same key, and as we know that the first few letters of the flag is crypto{, so we can get that key by doing the reverse , like the concept we used before, a^x = b , a = b^x,the code is ,,

input_str = bytes.fromhex('73626960647f6b206821204f21254f7d694f7624662065622127234f726927756d')

key = input_str[0] ^ ord('c')
print(''.join(chr(c ^ key) for c in input_str))

we get the flag as->crypto{0x10_15_my_f4v0ur173_by7e}


4)you either xor or you dont: in this challenge we still know the first few letters there , 7 bytes 'crypto{' by using the xor reversing like same as above, we get the key , which we have to repeat to match the length of the cipher, and that thing is done internally in the pwn.xor(), so the code is

from pwn import xor
k = bytes.fromhex('0e0b213f26041e480b26217f27342e175d0e070a3c5b103e2526217f27342e175d0e077e263451150104')
a = xor(k,b'crypto{')   # a gives myxoeke+y......., it means the key is myXORkey
print(xor(a.encode(),k)) # we have to encode a as xor() returns the string value ,but not bytes

hence the flag is ->crypto{1f_y0u_Kn0w_En0uGH_y0u_Kn0w_1t_4ll}


